# Basic Queries

Basic queries can be performed using a very familiar API to Hibernate 5's Criteria API: `addEq`, `addGt`, etc are all available inside the **Yawn**-scoped
lambda.

To create a query with **Yawn**, construct an instance of `Yawn` with a query factory and call `query`.

First, annotate the entity `DbFoo` with the `@YawnEntity` annotation. That will cause KSP to compile it into an additional object called `FooTable`.

Then, instead of:

```kotlin
val results = yawn.query(DbBook::class)
 .addEq("name", "The Hobbit")
 .list()
```

Do:

```kotlin
val results = yawn.query(BookTable) { books ->
  addEq(books.name, "The Hobbit")
}.list()
```

Letâ€™s break it down!

1. You need to provide the Table Definition object that was generated by **Yawn**. It will be called `<your-entity-name-minus-db>Table`.
2. You can immediately provide a block in order to filter down your query. That is where you can have your `addEq` and alike methods.
    1. You can also call `applyFilter` later if you want to pass the criteria around
3. The `books` parameter is the same object as `BookTable` for your convenience, and it is your starting point to access table columns. When you do a `join`
operation, you get other objects to access the new joined columns.
    1. **Yawn** makes sure you can only access root columns of the table you are querying or tables that you have joined!
4. The `.list()` call is done outside of the lambda. You will not have access to terminal operations inside the lambda.

## Other Available Criteria

The rest of the criteria can be found in `TypeSafeRestrictions` such as:

- `addEq`
- `addGt`
- `addLt`
- etcâ€¦

Note that these methods have a few overloads available, depending on what you want to compare:

- column with a value

```kotlin
val results = yawn.query(BookTable) { books ->
 addEq(book.name, "The Hobbit")
}.list()
```

- column with other column:

```kotlin
val results = yawn.query(BookTable) { books ->
 val authors = join(books.author)
 val bestWorks = join(authors.bestWork)
 addGt(book.rating, bestWorks.rating)
}.list()
```

- column with sub-query: [check the Sub-queries doc](sub_queries.md)

## Non-Column-Based Operations

Operations that do not require the column context are typically only available outside the lambda; such as:

- `offset`
- `maxResults`

For example:

```kotlin
val results = yawn.query(BookTable) { books ->
 addEq( ... ) // <- requires the column definition context
}
  .maxResults(10)
  .list()
```

Some operations that do require the column context are also available outside the lambda context (by providing their own lambda), such as:

- `applyFilter`
- `applyProjection`
- `minBy` / `maxBy`

## Terminal Operations

Terminal operations such as `uniqueResult` or `list` can only be called outside of the lambda, and they do not return the builder as they terminate the query.
These operations are defined in `BaseTypeSafeCriteriaBuilder` , such as:

- `list`
- `uniqueResult`
- `first`
- `minBy` / `maxBy`
- `paginateZeroIndexed`

## Pass/Modify Queries Around

If you want to â€œpassâ€ a query object around, you can just call `applyFilter` multiple times.

For example:

> [!NOTE]
> ðŸ§  Note that this is a slightly outdated example as we now support `paginateZeroIndexed` out of the box!

```kotlin
fun example(): List<DbBook> {
 val baseCriteria = yawn.query(BookTable)
 baseCriteria.applyFilter { books ->
  // base filters, must be ordered by token
 }
 return paginateAndExecute(baseCriteria)
}

// token based pagination
fun paginateAndExecute(
 criteria: TypeSafeCriteriaBuilder<DbBook, BookTable>,
): List<DbBook> {
 var lastToken: Token<Book> = null
 var results = mutableListOf<DbBook>()
 
 while (true) {
  val result = criteria.applyFilter { books ->
   // add pagination related filters
  }.list()
  
  if (result.isEmpty()) {
   break
  }
  
  lastToken = result.last().token
  results.addAll(result)
 }
 return results
}
```
